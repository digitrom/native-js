// __proto__ | prototype

class Car {
    constructor(brand, maxSpeed) {
        this.brand = brand
        this.maxSpeed = maxSpeed
    }

    engineStart() {
        console.log(`Start ${this.brand}`)
    }

    engineStop = () => {
        console.log(`Start ${this.brand}`)
    }
}

const car1 = new Car('bmw', 220)
const car2 = new Car('opel', 240)

console.log('car1', car1)
console.log('car2', car2)

// т.к. метод engineStart() создан с помощью function declaration, то он записывается в [[Prototype]] т.е
// он будет доступен для всех экземпляров класса Car
//а т.к. engineStop() - создан с помощью стрелочной функции, будет для каждого экземпляра новый, что не рекомендуется
// т.к. создается в оперативной памяти новый метод
//  пример наследования в гейм деве: Там использует ООП - т.е. все состоит из объектов. есть лес а в нем много деревьев и листьев.
//  И каждый лист движется. Функцию, отвечающую за движение листа создают с помощью function declaration (а не стрелочной)
//  т.е. записывается в класс. иначе для каждого листа создадуться отдельные функции и игра будет весить весить во много рпз больше
// во frontend это не особо актуально, так как мы не будем рендерить список на 1000 элементов, поэтому можно создавать с помощью => функции

