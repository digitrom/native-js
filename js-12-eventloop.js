//eventloop

// Бывает 2 типа структура данных для выполнения функций Сallstack и Task Queue(очередь)
//------------------------------------------------------Сallstack------------------------------------------------------
//1. callstack  - это структура данных для выполнения функций. на callstack  складываются вызовы наших функций и
// отрабатывают они по принципу LIFO - last in first out - Тот кто последним попал на стэк, тот первым выйдет из него
// пример LIFO
const a = () => {
    //undefined
//3. функция a отрабатывает, выходит из callstack, затем отрабатывает b - выходит из callstack, отрабатывает c-  выходит из callstack
}

const b = ()=> {
    a()// 2. функция b не отрабатывает т.к. запускает функцию a(поэтому ложится на  callstack) и ждет ее завершения
}

const c = () => {
    b() // 2. функция c не отрабатывает т.к. запускает функцию b(поэтому ложится на  callstack) и ждет ее завершения
}

c()// 1. запускаем функцию c (поэтому ложится на  callstack)

//---------------------------------------------------Task Queue--------------------------------------------------------

//2. Task Queue
// отрабатывают они по принципу FIFO - first in first out - Тот кто первым вошел, тот первым выйдет

//---------------------------------------------------Eventloop---------------------------------------------------------
// все асинхронные вызовы на фронтеде JS отдает в WebApis(т.е. Chrome) (ана бэке - Node.js)

//1 синхронный код выполняется поочередно =>  выполнится ('a'), следом идет асинхронный код, который мы не ждем, а
// выполняем строчка за строчкой код ниже => выполнится ('b'), затем ('c'), и в конце с задержкой в 1 сек. - ('timeout')
// если бы весь код выполнялся синхронно, приложение бы зависало на время пока не выполнится асинхронный код.
console.log('a')

setTimeout(function (){ // отправляется в WebApi, моментально уходит из WebApi в Callback Queue и висит там пока
    // не выполнятся все синхронные задачи (даже если timeout будет 0), т.е. пока  call stack  не опустеет
    console.log('timeout')
},1000)

console.log('b')
console.log('c')

//--------------------------------------------------------------Callback Queue-----------------------------------------

//case2
setTimeout(function timeout1(){
    console.log('timeout1')
},1000)
setTimeout(function timeout2(){
    console.log('timeout2')
},1000)
setTimeout(function timeout3(){
    console.log('timeout3')
},1000)

// в консоле будет в той же очередности, потому что в Callback Queue попадут тоже по очереди создания в коде
//----------------------------------------------------------------------------------------------------------------------
//case3
setTimeout(function timeout1(){//сначала колбэк timeout1 попадет в WebApi оттуда перескакивает в Callback Queue
    console.log('timeout1')
},1000)
setTimeout(function timeout2(){ // затем timeout2 попадет в WebApi оттуда перескакивает в Callback Queue и будет вторым в очереди
    //затем, как только код завершился, из Callback Queue в  callstack попадет тот, кто быстрее выполнится т.е timeout2
    console.log('timeout2')
},0)

