//eventloop

//Eventloop это некий цикл, написанный на C++ на стороне браузера,  который следит, когда Сallstack JS функций опустел,
// берет в порядке приоритета из 3 очередей таски и кладет их на стэк на выполнение
// все асинхронные вызовы на фронтеде, движок js отдает в WebApis(т.е. Chrome) (ана бэке - Node.js).Они висят в WebApis и "тикают" -
//ждут своего часа, когда попасть в ту или иную очередь - Microtask(промисы) Macrotasks (setTimeouts, setIntervals...)

// Бывает 2 типа структуры данных для выполнения функций Сallstack и Task Queue(очередь асинхр функц),
// которая делится на:
//1. Microtasks
//2. Render
//3. Macrotasks


//------------------------------------------------------Сallstack------------------------------------------------------
//1. callstack  - это структура данных для выполнения функций. В JS - существует только 1 стэк.
// на callstack  складываются вызовы наших функций и
// отрабатывают они по принципу LIFO - last in first out - Тот кто последним попал на стэк, тот первым выйдет из него
// пример LIFO
// const a = () => {
//     //undefined
// //3. функция a отрабатывает, выходит из callstack, затем отрабатывает b - выходит из callstack, отрабатывает c-  выходит из callstack
// }
//
// const b = ()=> {
//     a()// 2. функция b не отрабатывает т.к. запускает функцию a(поэтому ложится на  callstack) и ждет ее завершения
// }
//
// const c = () => {
//     b() // 2. функция c не отрабатывает т.к. запускает функцию b(поэтому ложится на  callstack) и ждет ее завершения
// }
//
// c()// 1. запускаем функцию c (поэтому ложится на  callstack)

//---------------------------------------------------Task Queue--------------------------------------------------------

//2. Task Queue
// отрабатывают они по принципу FIFO - first in first out - Тот кто первым вошел, тот первым выйдет

//---------------------------------------------------Eventloop---------------------------------------------------------
// все асинхронные вызовы на фронтеде JS отдает в WebApis(т.е. Chrome) (ана бэке - Node.js)

//case1

// console.log('a')
//
// setTimeout(function (){ // отправляется в WebApi, моментально уходит из WebApi в Callback Queue(Macrotasks) и висит там пока
//     // не выполнятся все синхронные задачи (даже если timeout будет 0), т.е. пока  call stack  не опустеет
//     console.log('timeout')
// },1000)
//
// console.log('b')
// console.log('c')

// синхронный код выполняется поочередно =>  выполнится ('a'), следом идет асинхронный код, который мы не ждем, а
// выполняем строчка за строчкой код ниже => выполнится ('b'), затем ('c'), и в конце с задержкой в 1 сек. - ('timeout')
// если бы весь код выполнялся синхронно, приложение бы зависало на время пока не выполнится асинхронный код.

//----------------------------------------------------------------------------------------------------------------------
//case2
// setTimeout(function timeout1(){//сначала колбэк timeout1 попадет в WebApi оттуда перескакивает в Callback Queue
//     console.log('timeout1')
// },1000)
// setTimeout(function timeout2(){ // затем timeout2 попадет в WebApi оттуда перескакивает в Callback Queue и будет вторым в очереди
//     //затем, как только код завершился, из Callback Queue в  callstack попадет тот, кто быстрее выполнится т.е timeout2
//     console.log('timeout2')
// },0)

//-------------------------------------3 очереди: MacroTask, Render, MicroTask----------------------------------------

// 1. Microtask - promises - у них САМЫЙ БОЛЬШОЙ приоритет
// 2. Render: отрисовка стилей, Rerender станицы, scroll  стриницы(т.е. анимация на странице). СРЕДНИЙ ПРИОРИТЕТ
// 3. MacroTask: setTimeout, setInterval,  обработчики событий (onClick, onChange, onFocus и т.д..) НИЗШИЙ ПРИОРИТЕТ


// Приоритет выполнения:
// Сначала Синхронные функции, затем в таком порядке:
//1. Microtasks
//2. Render
//3. Macrotasks

//Работают они следующим образом:
// движок js анализирует код. Когда он встречает вызов какой-то функции, он перемещает эту
// функцию в Call Stack. Если эта функция синхронная (например, console.log()), то она сразу же исполняется, покидает стэк
// и на её место приходит следующая функция. Если же эта функция асинхронная, например, setTimeout(), обработчик событий,
// то на помощь приходит браузер со своим Web API (мы же помним, что JavaScript - это однопоточный язык, и сам работать в
// многопоточном режиме он не может). Event Loop перемещает колбэк асинхронной функции в Web API, а сама асинхронная функция
// уходит из стэка вызовов. То есть, пока колбэк асинхронной функции находится под управлением Web API, движок js продолжает
// выполнять другие операции! если на стэк попадает промис, то он попадет в webApi, а затем как зарезолвится - в Microtasks
// затем Eventloop смотрит, если callstack  пустой, то сначала берет таски из Microtask(наивысший проритет из асинхр. операций),
// и кладет на стэк по очереди. Если в на стэк прилетает обычная синхронная функция, то выполняются сначала ее, затем
// возвращается в Microtask, завершает все их.  Потом смотрит на очередь Render.если там етсь таски, то берет оттуда ,
// по очереди, помещает их на callstack, если прилетает опять Microtask, то берет опять оттуда не смотря на Render,
// затем если Microtask нету больше, берется опять за Render, заканчивает их,
// затем берется  за Macrotask. если появляется новая
// задача в Render, то Eventloop заканчивает начатую макротаску, не смотрит на то, что еще есть макротаски,
// и опять берет из Render, так как у Render приоритет ВЫШЕ. как только в Render заканчиваются все таски, берется опять
// за макротакси.Этот процесс повторяется до тех пор, пока весь js код не будет выполнен.

// Event Loop - это специальный механизм на уровне движка js, который координирует работу 5-ти сущностей:
// Call Stack (стэк вызовов), Web API (API, предоставляемый браузером), очереди: Microtasks, Render, Macrotasks .


//---------------------------------------examples----------------------------------------------------------------------

//1.
// function a() {
//     b()
//     console.log('a')
// }
// function b() {
//     c()
//     console.log('b')
// }
// function c() {
//     console.log('c')
// }
// a();
// в консоле будет c, b, a
//----------------------------------------------------------------------------------------------------------------------
//2.
// function a() {
//     console.log('a')
// }
// function b() {
//     console.log('b')
// }
// function c() {
//     console.log('c')
// }
// a();
// setTimeout(function timer(){
//     console.log('timeout')
// },3000)
//
// b()
// c()

// в консоле будет  a,b,c, timeout
//---------------------------------------------------------------------------------------------------------------------

//3.
// function a() {
//     console.log('a')
// }
// function b() {
//     console.log('b')
// }
// function c() {
//     console.log('c')
// }
// a();
// new Promise(function (res,rej) { // выведется в консоле вторым, т.к. создание промиса это синхронная функция
//     console.log('create promise')
//     setTimeout(function timer(){
//         res(console.log('timeout'))//так как resolve внутри  setTimeout, то setTimeout будет перед then, не смотря на то,
//             //что then взвращает промис, а промис это Microtask, у которой приоритет выше чем у Macrotask(setTimeout)
//     },3000)
// }).then(()=> {
//     console.log('then')})
//
// b()
// c()

//a, create promise, b,c, timeout, then

//---------------------------------------------------------------------------------------------------------------------
//4.
// function a() {
//     console.log('a')
// }
// function b() {
//     console.log('b')
// }
// function c() {
//     console.log('c')
// }
// a();
// new Promise(function (res,rej) { // выведется в консоле вторым, т.к. создание промиса это синхронная функция
//     console.log('create promise')
//     setTimeout(function timer(){ //   попадает в Macrotasks
//         console.log('timeout')},0)
//     res()
// }).then(()=> {// попадает в Microtasks почти одновременно с setTimeout, (и даже позже на долю сек), но у Microtasks выше приоритет
//     console.log('then')})
//
// b()
// c()
//a, create promise, b,c,then, timeout
//--------------------------------------------------------------------------------------------------------------------
//5.
// setTimeout(function timer(){
//     console.log('timeout1')
// }, 1000)
// setTimeout(function timer(){
//     console.log('timeout2')
// }, 1000)
// setTimeout(function timer(){
//     console.log('timeout3')
// }, 1000)

// в консоле будет в той же очередности,timeout1, timeout2, timeout3
// потому что в Callback Queue(Macrotasks) попадут тоже по очереди создания в коде

//---------------------------------------------------------------------------------------------------------------------
//6.
// console.log('start')
// setTimeout(function timer(){
//     console.log('timeout1')
// }, 5000)
// setTimeout(function timer(){
//     console.log('timeout2')
// }, 3000)
// setTimeout(function timer(){
//     console.log('timeout3')
// }, 1000)
// setTimeout(function timer(){
//     console.log('timeout4')
// }, 1000)
// console.log('end')
//start
//end
//timeout3
//timeout4
//timeout2
//timeout1

//----------------------------------------------------------------------------------------------------------------------
//7.
// setTimeout(()=> {
//     console.log(1)
// })
//
// new Promise(function (res,rej){
//     console.log(2)
//     res()
// }).then(()=> {
//     console.log(3)
// })
//
// console.log(4)

//2,4,3,1
//---------------------------------------------------------------------------------------------------------------------

//8.
//
// setTimeout(()=> {
//     console.log(1)
// }, 0)
//
//
// new Promise(function (res,rej){
//     console.log(2)
//     res()//тут setTimeout с задержкой 0 и промис зарезолвятся практически одновременно, но так как промис - это Microtask =>выполнится 1-ым
// }).then(()=> {
//     console.log(3)
// })
//
// console.log(4)

//2,4,3,1

//----------------------------------------------------------------------------------------------------------------------

//9

// setTimeout(()=> {
//     console.log('s1') //  9. т.к. setTimeout - Macrotasks - приоритет ниже чем у Mшcrotasks
// }, 0)
//
// setTimeout(()=> {
//     console.log('s2') // 10
// }, 1000)
//
// new Promise(function (res,rej){
//     console.log('p1') //1. т.к. new Promise - обычная функция-констр, улетает сразу на callstack, которая выаолняется в синхнонном мире
//     res()
//     console.log('p2') //2. т.к. функция res() в данном случае тоже резолвится синхнонно
// }).then(()=> {
//     console.log('p3') //7. все синхронные задачи закочились, теперь идем в очередь микротасок(наивысший приоритет среди асинхронных операций)
//     // будет 7-ым т.к. 1-ый в очереди Microtasks. then - попадет в Microtasks, возовращает promise, а они идут в Microtasks
// })
//
// console.log('w1') // 3. обычная синхронная функция - улетает сразу на callstack
//
// async function test1(){
//     console.log('a1') //4. async - функция создания промиса - создается синхронно, улетает сразу на callstack
//     await test2() // пока await не выполнится, строчка ниже не выполняется
//     console.log('a2')  // 8. т.к. 2-ой в очереди Microtasks. await - тоже, что и then - попадет в Microtasks
// }
//
// async function test2(){
//     console.log('a3') //5. async - функция создания промиса - создается синхронно
// }
// test1()
//
// console.log('w2') //6. обычная синхронная функция - улетает сразу на callstack


//p1 -> p2 -> w1 -> a1 -> a3 -> w2 -> p3 -> a2 -> s1 -> s2


//-------------------------------------------------------------------------------------------
// 10.
//
// const myPromise = (delay) => {
//     console.log('1')
//     return new Promise((res,rej)=> {
//         setTimeout(res,delay)
//     })
// }
//
// setTimeout(()=> {
//     console.log('in setTimeout1')
// },1000)
//
// myPromise(1000).then(()=>console.log('in Promise 1'))
//
// setTimeout(()=> {
//     console.log('in setTimeout2')
// },100)
//
// myPromise(2000).then(()=>console.log('in Promise 2'))
// ответ
// 1
// 1
// in setTimeout2
// in setTimeout1
// in Promise 1
// in Promise 2

//  Сначала происходит этап выполнения синхронного кода и регистрация(отправка из callstack) асинхронного в webApi. т.е
//  сначала eventloop забирает на выполнение в  callstack синхронные функции, если они могут выполнится сразу, то выполняются, но  если внутри у них
//  асинхронные операции, то попадают в WebApi:
// 1. 1-ый setTimeout() - залетает на стэк первым (хоть внутри у него асинхронная операция, но вызов ее- это обычная функция).
// так как выполнится он не может сразу(так как setTimeout это api браузера ), удаляется из callstack, попадает в webApi и начинает тикать(отсчитывать 1сек.)
// 2. затем на стек попадает синхронная функция myPromise(1000), она запускается, и внутри нее есть console.log(), который
// тут же выполняеся. следующим запускается функция-конструктор создания промиса, кторая выполнится сразу не может,
// так как resolve внутри у setTimeout тоже выполнится сразу не может, поэтому удаляется из стэка,
// попадает в webApi и начинает тикать(отсчитывать 1сек.).
//3. далее, залетает на стэк 2-ой setTimeout - не выполяется и отправляется в webApi. задаржка короткая у него - 0,1 сек
//4. и последним на выполненрие на стэк попадает myPromise(2000), она запускается, и внутри нее есть console.log(), который
// тут же выполняеся. следующим запускается функция-конструктор создания промиса, кторая выполнится сразу не может,
// так как resolve внутри у setTimeout выполнится сразу не может, поэтому удаляется из стэка,
// попадает в webApi и начинает тикать(отсчитывать 2сек.).
//5. этот этап закончен, теперь наступает этап "расчистки" webApi и попадания асинхр. функций в свои очереди:
// в webApi зарегистрированы асинхр функции в след. порядке:
//setTimeout1(delay 1сек) 2. попадает в очередь Macrotasks 2-ым - выполняется - в консоле видим - 'in setTimeout2'
//Promise 1(delay 1сек) 3. попадает в очередь Microtasks 3им - выполняется - в консоле видим - in Promise 1
//setTimeout2(delay 0,1сек) - 1. попадает в очередь Macrotasks 1-ым - выполняется - в консоле видим - 'in setTimeout2'
//Promise 2(delay 2сек)  4. попадает в очередь Microtasks 4ым - выполняется - в консоле видим - in Promise 2

//--------------------------------------------------------------------------------------------------
//10a

// const myPromise = (delay) => {
//     console.log('1')
//     return new Promise((res,rej)=> {
//         res()
//         console.log('123')
//     })
// }
//
// setTimeout(()=> {
//     console.log('in setTimeout1')
// },1000)
//
// myPromise(1000).then(()=>console.log('in Promise 1'))
//
// setTimeout(()=> {
//     console.log('in setTimeout2')
// },100)
//
// myPromise(2000).then(()=>console.log('in Promise 2'))
// ответ
// 1
//123
// 1
//123
// in Promise 1
// in Promise 2
// in setTimeout2
// in setTimeout1
//---------------------------------------------------------------------------------------------------------------------
//11.

console.log(1)

setTimeout(() => {//движок идет по коду, видит не вложенный setTimeout и кладет на стэк, оттуда в в webApi на регистрацию
    console.log(2)
    Promise.resolve().then(() => { //Метод Promise.resolve(value) возвращает Promise выполненный с переданным значением
        console.log(3)
    })
})

new Promise((res, rej) => {
    console.log(4)
    res(5)
}).then((data) => {
    console.log(data)

    Promise.resolve().then(() => {
        console.log(6)
    }).then(() => {
        console.log(7)

        setTimeout(() => { // этот будет в конце после других setTimeout , потому что он вложенный в промисе
            // в конце(а других setTimeout-ы не вложенные, и регистируются сразу при 1-ом прохоже движка) , т.е. зарегистрируется
            // в webApi последним и соответственно уйдет в очередь Macrotask послендим => нас стэк и оттуда на выполнение тоже последним
            console.log(8)
        }, 0)
    })
})

setTimeout(() => {
    console.log(9)
})
console.log(10)

// 1, 4, 10, 5,6,7,2,3,9,8